import random

# 定义粒子类
class Particle:
    def __init__(self, cities):
        self.position = random.sample(cities, len(cities))  # 当前位置（路径）
        self.velocity = [0] * len(cities)  # 初始化速度
        self.best_position = self.position.copy()  # 最佳位置
        self.best_distance = total_distance(self.position)  # 最佳距离

# 更新粒子位置
def update_position(particle, gbest_position):
    new_position = particle.position.copy()
    for i in range(len(particle.velocity)):
        if random.random() < abs(particle.velocity[i]):
            # 选择一个城市与当前位置交换
            swap_index = random.randint(0, len(new_position) - 1)
            new_position[i], new_position[swap_index] = new_position[swap_index], new_position[i]
    return new_position

# 更新粒子速度
def update_velocity(particle, gbest_position, w, c1, c2):
    new_velocity = particle.velocity.copy()
    for i in range(len(particle.velocity)):
        # 计算速度
        r1 = random.random()
        r2 = random.random()
        cognitive_velocity = c1 * r1 * (particle.best_position[i] != particle.position[i])
        social_velocity = c2 * r2 * (gbest_position[i] != particle.position[i])
        new_velocity[i] = w * particle.velocity[i] + cognitive_velocity + social_velocity
    return new_velocity

# 粒子群优化算法
def particle_swarm_optimization(cities, num_particles, num_generations):
    # 初始化粒子群
    particles = [Particle(cities) for _ in range(num_particles)]
    
    # 初始化全局最佳位置
    gbest_position = min(particles, key=lambda p: p.best_distance).best_position
    gbest_distance = total_distance(gbest_position)

    # 粒子群优化的参数
    w = 0.5  # 惯性权重
    c1 = 0.8  # 个体认知因子
    c2 = 0.9  # 社会认知因子

    for _ in range(num_generations):
        for particle in particles:
            # 更新速度和位置
            particle.velocity = update_velocity(particle, gbest_position, w, c1, c2)
            particle.position = update_position(particle, gbest_position)

            # 更新个体最佳位置
            current_distance = total_distance(particle.position)
            if current_distance < particle.best_distance:
                particle.best_position = particle.position.copy()
                particle.best_distance = current_distance

            # 更新全局最佳位置
            if current_distance < gbest_distance:
                gbest_position = particle.position.copy()
                gbest_distance = current_distance

    return gbest_position, gbest_distance

# 设置参数
num_particles = 50
num_generations = 1000

# 修正计算总距离的函数
def total_distance(path, cities_coordinates):
    dist = sum(distance(cities_coordinates[path[i]], cities_coordinates[path[i - 1]]) for i in range(1, len(path)))
    dist += distance(cities_coordinates[path[0]], cities_coordinates[path[-1]])
    return dist

# 粒子群优化算法（针对TSP问题的调整）
def particle_swarm_optimization(cities, num_particles, num_generations):
    # 初始化粒子群
    particles = [Particle(cities) for _ in range(num_particles)]
    
    # 初始化全局最佳位置
    gbest_position = min(particles, key=lambda p: total_distance(p.best_position, cities)).best_position
    gbest_distance = total_distance(gbest_position, cities)

    # 粒子群优化的参数
    w = 0.5  # 惯性权重
    c1 = 0.8  # 个体认知因子
    c2 = 0.9  # 社会认知因子

    for _ in range(num_generations):
        for particle in particles:
            # 更新速度和位置
            particle.velocity = update_velocity(particle, gbest_position, w, c1, c2)
            particle.position = update_position(particle, gbest_position)

            # 更新个体最佳位置
            current_distance = total_distance(particle.position, cities)
            if current_distance < total_distance(particle.best_position, cities):
                particle.best_position = particle.position.copy()
                particle.best_distance = current_distance

            # 更新全局最佳位置
            if current_distance < gbest_distance:
                gbest_position = particle.position.copy()
                gbest_distance = current_distance

    return gbest_position, gbest_distance

# 修正 Particle 类的初始化以适应新的 total_distance 函数
class Particle:
    def __init__(self, cities_coordinates):
        self.position = random.sample(range(len(cities_coordinates)), len(cities_coordinates))  # 当前位置（路径）
        self.velocity = [0] * len(cities_coordinates)  # 初始化速度
        self.best_position = self.position.copy()  # 最佳位置
        self.best_distance = total_distance(self.position, cities_coordinates)  # 最佳距离

# 执行粒子群优化算法
best_path, best_distance = particle_swarm_optimization(cities, num_particles, num_generations)
print("最佳路径:", best_path)
print("最短距离:", best_distance)

# 绘制最佳路径
plot_path(best_path)
plt.show()
